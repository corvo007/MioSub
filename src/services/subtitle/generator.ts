import { type SubtitleItem } from '@/types/subtitle';
import { type SpeakerUIProfile } from '@/types/speaker';
import { toAssTime } from '@/services/subtitle/time';
import { getSpeakerColorWithCustom } from '@/services/utils/colors';
import { sanitizeSpeakerForStyle } from './utils';
import { containsJapaneseKana, isJapanese } from '@/services/utils/language';

// Helper to convert Hex (#RRGGBB) to ASS BGR (&HBBGGRR)
// Helper to convert Hex (#RRGGBB) to ASS BGR (&HBBGGRR)
const hexToAssBgr = (hex?: string): string => {
  if (!hex) return '&H00FFFFFF'; // Default to white
  const cleanHex = hex.replace('#', '');
  const r = cleanHex.substring(0, 2);
  const g = cleanHex.substring(2, 4);
  const b = cleanHex.substring(4, 6);
  return `&H00${b}${g}${r}`;
};

/**
 * Returns the preferred font for original text based on content detection.
 * Uses per-line kana detection to handle mixed-language content correctly.
 */
const getFontForOriginal = (text: string): string => {
  return containsJapaneseKana(text) ? 'Noto Sans JP' : 'Noto Sans SC';
};

export const generateSrtContent = (
  subtitles: SubtitleItem[],
  bilingual: boolean = true,
  includeSpeaker: boolean = false
): string => {
  return subtitles
    .map((sub, index) => {
      // Conditionally prepend speaker name
      const speakerPrefix = includeSpeaker && sub.speaker ? `${sub.speaker}: ` : '';

      // If bilingual is true, show original then translated. If false, only translated.
      const originalLine = speakerPrefix + sub.original;
      const translatedLine = speakerPrefix + sub.translated;
      const text = bilingual ? `${originalLine}\n${translatedLine}` : translatedLine;

      return `${index + 1}
${sub.startTime} --> ${sub.endTime}
${text}
`;
    })
    .join('\n');
};

export const generateAssContent = (
  subtitles: SubtitleItem[],
  title: string,
  bilingual: boolean = true,
  includeSpeaker: boolean = false,
  useSpeakerColors: boolean = false,
  speakerProfiles?: SpeakerUIProfile[],
  targetLanguage?: string,
  videoDimensions?: { width: number; height: number }
): string => {
  // PlayRes & font sizes: base values are calibrated for 1920×1080.
  // For other resolutions (e.g. vertical 1080×1920), scale proportionally by width.
  const playResX = videoDimensions?.width || 1920;
  const playResY = videoDimensions?.height || 1080;
  const fontScale = playResX / 1920;
  const baseFontSize = Math.round(82 * fontScale);
  const secondaryFontSize = Math.round(54 * fontScale);

  // Translated text font: Use targetLanguage setting directly (no detection needed)
  // This fixes the bug where Japanese source content caused Chinese translations to use JP font
  const isTargetJapanese = targetLanguage ? isJapanese(targetLanguage) : false;
  const langTranslated: 'ja' | 'zh' = isTargetJapanese ? 'ja' : 'zh';

  // Default font for styles (based on target language)
  const defaultFont = langTranslated === 'ja' ? 'Noto Sans JP' : 'Noto Sans SC';
  // Font for translated text (same as default, based on target language)
  const fontTranslated = defaultFont;

  // Generate speaker styles
  // We prefer to iterate over ALL profiles if provided, or derive unique speakers from subtitles if not.
  // Using profiles allows us to include styles even for speakers not currently speaking (metadata preservation)
  // and maintain stable mapping.

  let speakerStylesStr = '';

  if (useSpeakerColors) {
    // If we have profiles, use them to generate robust ID-based styles
    if (speakerProfiles && speakerProfiles.length > 0) {
      speakerStylesStr = speakerProfiles
        .map((profile) => {
          const color = getSpeakerColorWithCustom(profile.name, profile.color);
          const bgrColor = hexToAssBgr(color);
          const sanitizedSpeaker = sanitizeSpeakerForStyle(profile.name);

          // Use ShortID if available for Uniqueness, otherwise just sanitized name
          const uniqueSuffix = profile.shortId ? `_${profile.shortId}` : '';
          const styleName = `Speaker_${sanitizedSpeaker}${uniqueSuffix}`;

          return `Style: ${styleName},${defaultFont},${baseFontSize},${bgrColor},&H000000FF,&H00000000,&H00800000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1`;
        })
        .join('\n');
    } else {
      // Fallback: derive from subtitles (Legacy/No-Profile mode)
      const uniqueSpeakers = Array.from(
        new Set(subtitles.map((s) => s.speaker).filter(Boolean))
      ) as string[];
      speakerStylesStr = uniqueSpeakers
        .map((speaker) => {
          const color = getSpeakerColorWithCustom(speaker);
          const bgrColor = hexToAssBgr(color);
          const sanitizedSpeaker = sanitizeSpeakerForStyle(speaker);
          const styleName = `Speaker_${sanitizedSpeaker}`;
          return `Style: ${styleName},${defaultFont},${baseFontSize},${bgrColor},&H000000FF,&H00000000,&H00800000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1`;
        })
        .join('\n');
    }
  }

  const header = `[Script Info]
; Script generated by MioSub
Title: ${title}
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: ${playResX}
PlayResY: ${playResY}

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,${defaultFont},${baseFontSize},&H00FFFFFF,&H000000FF,&H00000000,&H00800000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1
Style: Secondary,${defaultFont},${secondaryFontSize},&H0000FFFF,&H000000FF,&H00000000,&H00800000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1
${speakerStylesStr}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  const events = subtitles
    .map((sub) => {
      const start = toAssTime(sub.startTime);
      const end = toAssTime(sub.endTime);

      // Handle speaker prefix if enabled (in explicit text)
      const speakerPrefix = includeSpeaker && sub.speaker ? `${sub.speaker}: ` : '';

      // Prepare raw text
      const originalText = speakerPrefix + (sub.original || '');
      const translatedText = speakerPrefix + (sub.translated || '');
      const cleanOriginal = originalText.replace(/\n/g, '\\N').replace(/\r/g, '');
      const cleanTranslated = translatedText.replace(/\n/g, '\\N').replace(/\r/g, '');

      // Original text: per-line detection to handle mixed-language content
      const fontOriginal = getFontForOriginal(sub.original || '');
      // Translated text: use pre-determined font based on targetLanguage setting

      // Determine Style Name
      let style = 'Default';
      if (useSpeakerColors) {
        if (sub.speakerId && speakerProfiles) {
          // ID-based lookup (Strong Link)
          let profile = speakerProfiles.find((p) => p.id === sub.speakerId);

          // Fallback: Name-based lookup if ID failed but name exists
          if (!profile && sub.speaker) {
            profile = speakerProfiles.find((p) => p.name === sub.speaker);
          }

          if (profile) {
            const sanitizedSpeaker = sanitizeSpeakerForStyle(profile.name);
            const uniqueSuffix = profile.shortId ? `_${profile.shortId}` : '';
            style = `Speaker_${sanitizedSpeaker}${uniqueSuffix}`;
          } else if (sub.speaker) {
            // Fallback to name if generic (Speaker not in profile list)
            style = `Speaker_${sanitizeSpeakerForStyle(sub.speaker)}`;
          }
        } else if (sub.speaker) {
          // Fallback to name-based (Legacy)
          style = `Speaker_${sanitizeSpeakerForStyle(sub.speaker)}`;
        }
      }

      let text = '';
      if (bilingual) {
        // Layout: Original (Small/Secondary) on TOP (Secondary Style). Translated (Large/Default/SpeakerStyle) on BOTTOM.
        text = `{\\rSecondary}{\\fn${fontOriginal}}${cleanOriginal}\\N{\\r${style}}{\\fn${fontTranslated}}${cleanTranslated}`;
      } else {
        text = `{\\fn${fontTranslated}}${cleanTranslated}`;
      }

      const nameField = sub.speaker || '';

      return `Dialogue: 0,${start},${end},${style},${nameField},0,0,0,,${text}`;
    })
    .join('\n');

  return header + events;
};
