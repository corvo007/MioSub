import { SubtitleItem } from '@/types/subtitle';
import { toAssTime } from './time';
import { getSpeakerColor } from '@/utils/colors';

// Helper to convert Hex (#RRGGBB) to ASS BGR (&HBBGGRR)
const hexToAssBgr = (hex: string): string => {
  const cleanHex = hex.replace('#', '');
  const r = cleanHex.substring(0, 2);
  const g = cleanHex.substring(2, 4);
  const b = cleanHex.substring(4, 6);
  return `&H00${b}${g}${r}`;
};

export const generateSrtContent = (
  subtitles: SubtitleItem[],
  bilingual: boolean = true,
  includeSpeaker: boolean = false
): string => {
  return subtitles
    .map((sub, index) => {
      // Conditionally prepend speaker name
      const speakerPrefix = includeSpeaker && sub.speaker ? `${sub.speaker}: ` : '';

      // If bilingual is true, show original then translated. If false, only translated.
      const originalLine = speakerPrefix + sub.original;
      const translatedLine = speakerPrefix + sub.translated;
      const text = bilingual ? `${originalLine}\n${translatedLine}` : translatedLine;

      return `${index + 1}
${sub.startTime} --> ${sub.endTime}
${text}
`;
    })
    .join('\n');
};

export const generateAssContent = (
  subtitles: SubtitleItem[],
  title: string,
  bilingual: boolean = true,
  includeSpeaker: boolean = false,
  useSpeakerColors: boolean = false
): string => {
  // Updated Styles:
  // Default: Fontsize 75 (Large), White (Primary) -> Used for Translation
  // Secondary: Fontsize 48 (Small), Yellow (Original) -> Used for Original Text

  // Extract unique speakers if colors are enabled
  const uniqueSpeakers = useSpeakerColors
    ? (Array.from(new Set(subtitles.map((s) => s.speaker).filter(Boolean))) as string[])
    : [];

  // Generate speaker styles
  const speakerStyles = uniqueSpeakers
    .map((speaker) => {
      const color = getSpeakerColor(speaker);
      const bgrColor = hexToAssBgr(color);
      // Inherit from Default but change PrimaryColour
      // Sanitize speaker name for style name
      const styleName = `Speaker_${speaker.replace(/\s+/g, '_')}`;
      return `Style: ${styleName},Arial,75,${bgrColor},&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,3,2,2,10,10,10,1`;
    })
    .join('\n');

  const header = `[Script Info]
; Script generated by Gemini Subtitle Pro
Title: ${title}
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,75,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,3,2,2,10,10,10,1
Style: Secondary,Arial,48,&H0000FFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,3,2,2,10,10,10,1
${speakerStyles}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  const events = subtitles
    .map((sub) => {
      const start = toAssTime(sub.startTime);
      const end = toAssTime(sub.endTime);

      // Conditionally prepend speaker name
      const speakerPrefix = includeSpeaker && sub.speaker ? `${sub.speaker}: ` : '';

      const originalText = speakerPrefix + (sub.original || '');
      const translatedText = speakerPrefix + (sub.translated || '');

      const cleanOriginal = originalText.replace(/\n/g, '\\N').replace(/\r/g, '');
      const cleanTranslated = translatedText.replace(/\n/g, '\\N').replace(/\r/g, '');

      // Determine style
      let style = 'Default';
      if (useSpeakerColors && sub.speaker) {
        style = `Speaker_${sub.speaker.replace(/\s+/g, '_')}`;
      }

      let text = '';
      if (bilingual) {
        // Layout: Original (Small/Secondary) on TOP. Translated (Large/Default) on BOTTOM.
        // \rSecondary sets style to Secondary. \r resets to Default (or current line style).
        text = `{\\rSecondary}${cleanOriginal}\\N{\\r}${cleanTranslated}`;
      } else {
        // Just translated text using Default style (large) (or speaker style)
        text = cleanTranslated;
      }

      // Always write speaker to Name field for metadata (re-import support)
      const nameField = sub.speaker || '';

      return `Dialogue: 0,${start},${end},${style},${nameField},0,0,0,,${text}`;
    })
    .join('\n');

  return header + events;
};
