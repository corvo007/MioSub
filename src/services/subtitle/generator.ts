import { type SubtitleItem } from '@/types/subtitle';
import { type SpeakerUIProfile } from '@/types/speaker';
import { toAssTime } from '@/services/subtitle/time';
import { getSpeakerColorWithCustom } from '@/services/utils/colors';
import { sanitizeSpeakerForStyle } from './utils';
import { containsJapaneseKana } from '@/services/utils/language';

// Helper to convert Hex (#RRGGBB) to ASS BGR (&HBBGGRR)
// Helper to convert Hex (#RRGGBB) to ASS BGR (&HBBGGRR)
const hexToAssBgr = (hex?: string): string => {
  if (!hex) return '&H00FFFFFF'; // Default to white
  const cleanHex = hex.replace('#', '');
  const r = cleanHex.substring(0, 2);
  const g = cleanHex.substring(2, 4);
  const b = cleanHex.substring(4, 6);
  return `&H00${b}${g}${r}`;
};

/**
 * Returns the preferred font based on language content.
 * JP -> MS Mincho (Serif/Mincho) - Matches standard Japanese subtitle aesthetics
 * CN/Other -> Noto Sans SC (Sans-serif) - Matches standard Chinese aesthetics
 */
const getFontForText = (text: string, languageCode?: string): string => {
  if (languageCode === 'ja') return 'Noto Sans JP';
  if (languageCode === 'zh') return 'Noto Sans SC';
  return containsJapaneseKana(text) ? 'Noto Sans JP' : 'Noto Sans SC';
};

export const generateSrtContent = (
  subtitles: SubtitleItem[],
  bilingual: boolean = true,
  includeSpeaker: boolean = false
): string => {
  return subtitles
    .map((sub, index) => {
      // Conditionally prepend speaker name
      const speakerPrefix = includeSpeaker && sub.speaker ? `${sub.speaker}: ` : '';

      // If bilingual is true, show original then translated. If false, only translated.
      const originalLine = speakerPrefix + sub.original;
      const translatedLine = speakerPrefix + sub.translated;
      const text = bilingual ? `${originalLine}\n${translatedLine}` : translatedLine;

      return `${index + 1}
${sub.startTime} --> ${sub.endTime}
${text}
`;
    })
    .join('\n');
};

// Heuristic: If > threshold of lines contain Japanese Kana, assume the track is Japanese.
// Threshold protects against "teaching videos" (mixed content) or AI hallucinations.
const detectLanguageForLines = (lines: string[]): 'ja' | 'zh' => {
  const total = lines.length;
  if (total === 0) return 'zh';

  const kanaCount = lines.filter((text) => containsJapaneseKana(text)).length;
  // Threshold: If more than 5% of lines OR more than 5 lines (absolute) contain Kana, it's Japanese.
  // This allows short Japanese clips to work, while ignoring occasional accidental Kana in Chinese tracks.
  const isJapanese = kanaCount > 0 && (kanaCount / total > 0.05 || kanaCount > 5);

  return isJapanese ? 'ja' : 'zh';
};

export const generateAssContent = (
  subtitles: SubtitleItem[],
  title: string,
  bilingual: boolean = true,
  includeSpeaker: boolean = false,
  useSpeakerColors: boolean = false,
  speakerProfiles?: SpeakerUIProfile[]
): string => {
  // Updated Styles:
  // Default: Fontsize 75 (Large), White (Primary) -> Used for Translation
  // Secondary: Fontsize 48 (Small), Yellow (Original) -> Used for Original Text

  // Detect language separately for Original and Translated tracks
  // This ensures that if the user translates JP -> CN, top line is JP font, bottom is CN font.
  const langOriginal = detectLanguageForLines(subtitles.map((s) => s.original));
  const langTranslated = detectLanguageForLines(subtitles.map((s) => s.translated));

  // Default font for styles (fallback/template usage) - prioritize Translated language
  const defaultFont = langTranslated === 'ja' ? 'Noto Sans JP' : 'Noto Sans SC';

  // Extract unique speakers if colors are enabled
  const uniqueSpeakers = useSpeakerColors
    ? (Array.from(new Set(subtitles.map((s) => s.speaker).filter(Boolean))) as string[])
    : [];

  // Generate speaker styles
  const speakerStyles = uniqueSpeakers
    .map((speaker) => {
      const profile = speakerProfiles?.find((p) => p.name === speaker);
      const color = getSpeakerColorWithCustom(speaker, profile?.color);
      const bgrColor = hexToAssBgr(color);
      // Inherit from Default but change PrimaryColour
      // Sanitize speaker name for style name - remove all ASS-illegal characters
      // ASS style names should only contain alphanumeric, underscore, and safe Unicode chars
      const sanitizedSpeaker = sanitizeSpeakerForStyle(speaker);
      const styleName = `Speaker_${sanitizedSpeaker || 'Unknown'}`;
      // MioSub Speaker Style: Inherits branding, defaults to Noto Sans SC for CJK safety on Windows
      // The font for speaker styles will be determined dynamically per line, so we use a default here.
      return `Style: ${styleName},${defaultFont},82,${bgrColor},&H000000FF,&H00000000,&H00800000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1`;
    })
    .join('\n');

  const header = `[Script Info]
; Script generated by MioSub
Title: ${title}
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,${defaultFont},82,&H00FFFFFF,&H000000FF,&H00000000,&H00800000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1
Style: Secondary,${defaultFont},54,&H0000FFFF,&H000000FF,&H00000000,&H00800000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1
${speakerStyles}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;

  const events = subtitles
    .map((sub) => {
      const start = toAssTime(sub.startTime);
      const end = toAssTime(sub.endTime);

      // Handle speaker prefix if enabled
      const speakerPrefix = includeSpeaker && sub.speaker ? `${sub.speaker}: ` : '';

      // Prepare raw text
      const originalText = speakerPrefix + (sub.original || '');
      const translatedText = speakerPrefix + (sub.translated || '');

      // Clean text for ASS
      const cleanOriginal = originalText.replace(/\n/g, '\\N').replace(/\r/g, '');
      const cleanTranslated = translatedText.replace(/\n/g, '\\N').replace(/\r/g, '');

      // Determine dynamic fonts
      // We check the original/translated content (excluding speaker prefix) check for detecting language
      const fontOriginal = getFontForText(sub.original || '', langOriginal);
      const fontTranslated = getFontForText(sub.translated || '', langTranslated);

      // Determine base style
      let style = 'Default';
      if (useSpeakerColors && sub.speaker) {
        style = `Speaker_${sanitizeSpeakerForStyle(sub.speaker)}`;
      }

      let text = '';
      if (bilingual) {
        // Layout: Original (Small/Secondary) on TOP. Translated (Large/Default) on BOTTOM.
        // Use explicit \fn overrides for language-specific fonts
        // Note: {\r} (implicit reset) causes double-rendering issues in some libass versions.
        // Using explicit {\rStyleName} fixes the rendering bug.
        text = `{\\rSecondary}{\\fn${fontOriginal}}${cleanOriginal}\\N{\\r${style}}{\\fn${fontTranslated}}${cleanTranslated}`;
      } else {
        // Just translated text using Default style (large)
        text = `{\\fn${fontTranslated}}${cleanTranslated}`;
      }

      // Always write speaker to Name field for metadata (re-import support)
      const nameField = sub.speaker || '';

      return `Dialogue: 0,${start},${end},${style},${nameField},0,0,0,,${text}`;
    })
    .join('\n');

  return header + events;
};
